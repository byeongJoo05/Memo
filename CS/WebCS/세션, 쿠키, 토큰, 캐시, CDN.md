# 세션(Session), 쿠키(Cookie), 토큰(Token), 캐시(Cache), CDN

## HTTP, 비상태 프로토콜(Stateless Protocol)

HTTP는 TCP를 전송 프로토콜로 사용한다. HTTP 클라이언트는 서버에 TCP 연결을 시작하고, 연결이 이루어지면 브라우저와 서버 프로세스는 소켓 인터페이스를 통해 TCP로 접속한다.

클라이언트는 HTTP 요청 메시지를 소켓 인터페이스로 보내고 소켓 인터페이스로부터 HTTP 응답 메시지를 받는다. 마찬가지로 HTTP 서버는 소켓 인터페이스로부터 요청 메시지를 받고 응답 메시지를 소켓 인터페이스로 보낸다.

즉, 클라이언트가 메시지를 소켓 인터페이스로 보내면 해당 메시지는 이미 클라이언트의 손을 떠나 TCP의 손에 쥐어지게 되는 것이다. 그리고 TCP는 HTTP에게 신뢰적인 데이터 전송 서비스를 제공하기 때문에 클라이언트 프로세스가 발생시킨 모든 HTTP 요청 메시지는 궁극적으로 서버에 잘 도착하게 되고, 마찬가지로 서버 프로세스가 발생시킨 각 HTTP 응답 메시지도 클라이언트에 잘 도착하게 되는 것이다.

한편, 이러한 소켓 인터페이스를 통한 통신을 들여다보면, **서버가 클라이언트에게 요청 파일을 보낼 때 서버는 클라이언트에 관한 어떤 상태 정보도 저장하지 않는다.** 만약 클라이언트가 몇 초 후에 같은 객체를 두 번 요청하면, 직전에 그 객체를 보냈다고 서버가 알려주면 좋겠지만 서버는 이전에 한 일을 기억하지 않으므로 그 객체를 또 보내게 된다.

![image](https://github.com/byeongJoo05/Memo/assets/84984586/105f9544-5112-470d-8bb4-d4557762d716)

따라서 HTTP 서버는 클라이언트에 대한 정보를 유지하지 않는다는 점에서 HTTP를 `비상태 프로토콜(stateless protocol)`이라고 한다.

쿠키(Cookie)의 필요성은 바로 이 상태에서부터 시작하게 된다.

## 쿠키(Cookie)

개발하다 보면 유저의 접속을 제한하거나 유저에 따라 컨텐츠 접근에 제한을 두길 원할 때가 있다.

서버는 이를 위해 필연적으로 유저의 정보를 기억해야 한다. 이는 HTTP의 비상태성과 모순되는 개념이기에 HTTP는 `쿠키`라는 기술을 통해 이 목적을 달성하려고 한다.

아래 그림처럼 쿠키 기술은 네 가지 요소, **(1) HTTP 응답 메시지 쿠키 헤더 라인, (2) HTTP 요청 메시지 쿠키 헤더 라인, (3) 사용자 브라우저에 사용자 종단 시스템과 관리를 지속시키는 쿠키 파일, (4) 웹 사이트의 백엔드 데이터베이스**를 가지고 있다.

![img1 daumcdn](https://github.com/byeongJoo05/Memo/assets/84984586/f3b15d7e-59cc-47fa-a92e-dab74018a056)

만약 이전에 구글을 방문한 기록이 있고, 오늘 네이버를 처음 방문했다고 가정하자. 그러면 아래와 같은 로직에 따라 쿠키가 생성되고 사용된다.

- 최초에 네이버 웹 서버에 요청이 들어올 때 네이버 서버는 유일한 식별번호를 만들고 이 식별번호로 인덱스되는 백엔드 DB 안에 엔트리를 만들게 된다.
- 그런 후 네이버 서버는 사용자의 브라우저에 응답을 할 때 이 HTTP 응답 식별번호를 담고 있는 Set-Cookie: 헤더를 포함시켜 응답한다.
- 사용자 브라우저가 HTTP 응답 메시지를 받았을 때 그 Set-Cookie: 헤더를 볼 수 있다. 그 다음 브라우저는 자신이 관리하는 특정한 쿠키 파일에 그 라인을 덧붙이게 된다.
- 이 라인은 서버의 호스트 네임과 Set-Cookie: 헤더와 식별번호를 가지고 있기 때문에 이후에 네이버에 접속을 하게 되면 브라우저는 쿠키 파일을 참조해서 네이버 사이트에 대한 식별 번호를 발췌하고, HTTP 요처에 식별 번호를 포함하는 쿠키 헤더 파일을 넣어 보내게 된다.
- 그러면 네이버 서버는 식별번호를 통해 식별할 수 있게 되고, 사용자의 활동 기록들을 추적할 수 있게 된다.

## 세션(Session)

**세션은 쿠키를 기반으로 하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버측에서 관리를 한다.**

서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며, 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지한다. 물론 우리가 웹 서버에 로그인을 해두고 외출을 하고 오면 로그아웃이 되는 것처럼, 일정 시간을 설정해서 세션을 날릴 수도 있다.

세션의 동작 원리는 아래와 같다.

- 클라이언트가 서버에 접속할 때 세션 ID를 발급한다.
- 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 있다.
- 클라이언트가 서버에 요청을 할 때 쿠키의 세션 ID를 같이 서버에 전달해서 요청한다.
- 서버는 세션 ID를 받아서 세션을 존재하는 클라이언트의 정보를 가져와서 사용한다.

앞서 말했듯, 세션은 쿠키와 비슷한 방식으로 동작하지만 **쿠키는 브라우저에 저장되기 때문에 서버의 자원을 사용하지 않으며, 세션은 서버에 저장되기 때문에 서버의 자원을 사용하는 차이점**이 있다.

**그리고 이 차이점으로 인해 세션은 쿠키보다 보안에서 우수하고, 메모리 상으로는 불리한 면을 가지게 된다.**

쿠키는 클라이언트 브라우저에 저장되기 때문에 요청을 보낼 때 스니핑을 당할 수 있어서 보안에 취약하지만 세션은 쿠키를 이용해서 세션 아이디만 저장하고 이를 통해 클라이언트를 식별해서 서버에서 처리를 하기 때문에 보안에서 이점을 가지게 된다. 반면, 세션은 서버의 자원을 사용하기 때문에 모든 쿠키를 대신하여 세션을 이용하게 되면 서버에 대한 부하가 커지게 되는 단점을 가지게 된다.

## 토큰(Token)

메모리 공간을 많이 차지하는 세션 방식의 대안은 로그인한 사용자에게 세션 아이디 대신 `토큰(Token)`을 발급해 주는 것이다. 이러한 토큰에는 특수한 수학적 원리가 적용되어 있어 마치 위조방지 장치가 있는 지폐처럼 서버만이 유효한 토큰을 발행할 수 있다.

![img1 daumcdn](https://github.com/byeongJoo05/Memo/assets/84984586/a682a4f2-75d9-4f63-aa57-a240aba7b7ab)

그렇기에 토큰을 받아간 사용자가 이를 쿠키로 저장해 두고 필요할 때마다 제시하면 서버는 따로 책상에 올려놓은 것을 확인할 필요 없이 자기가 발급한 토큰임을 알아보고 사용자의 요청을 허가해 주는 것이다. 더 이상 이미 로그인한 사용자의 티켓을 메모리에 올려두고 있을 필요가 없으니 서버 부하를 줄일 수 있다.

> 토큰 방식은 해당 서버만이 만들 수 있는 토큰을 발급함으로써 상태를 저장하지 않고도 사용자의 로그인 여부를 파악할 수 있도록 한다.
> 

물론 토큰 방식에도 한계는 있다. 여러 기기에서의 로그인을 제한하기 위해 필요할 때에 로그인되어 있는 사용자를 서버가 강제로 로그아웃을 시킬 수 있어야 하는데, 토큰 방식에서는 이것이 불가능하다. 한 번 발행한 토큰은 유효기간이 끝나기 전까지 통제할 수 없기 때문에 세션에 비해 토큰 정보를 탈취 당할 가능성이 높다. 토큰은 쿠키처럼 만료 기간을 정할 수 있어서 만료 시간을 짧게 지정해 피해를 줄일 수 있다. 토큰방식은 쿠키와 세션을 적절히 섞은 것과 비슷하다.

|  | 세션 방식 | 토큰 방식 |
| --- | --- | --- |
| 장점 | 사용자의 상태를 원하는대로 통제 가능 | 상태를 따로 기억해 둘 필요가 없음 |
| 단점 | 메모리에 로그인되어 있는 사용자의 상태를 보관해야 함 | 한 번 로그인한 사용자의 상태의 토큰 |

## 웹 캐시(Cache)

웹 캐시는 쉽게 말해 원래 웹 서버를 대신하여 HTTP 통신을 대신하는 네트워크 개체를 말한다.

**웹 캐시는 자체적인 저장 디스크를 가지고 있어서 최근에 호출된 객체의 사본을 저장 및 보존**하고 있다. 그래서 **사용자의 HTTP 데이터 요청이 있으면 웹 캐시에서 해당 데이터를 찾아서 있으면 보내주고, 없으면 원래 서버에게 해당 데이터를 요청받아 사용자에게 넘겨주고 자신의 저장소 안에도 저장**해두는 것이다.

캐시는 사용자의 요청을 자신이 대신 처리해줌으로써 원래 서버에 대한 트래픽 강도를 낮추게 하고, 이를 통해 응답 속도를 개선하는 역할을 한다고 이해하면 된다.

> 쿠키와 캐시의 차이
쿠키와 캐시 모두 정보를 저장하여 재활용하는 기술이지만, 쿠키는 사용자의 수고를 덜어주는 데 목적을 두고 캐시는 데이터의 전송량을 줄이고 서비스 이용 속도를 높이는데 목적을 둔다.
> 

## CDN

캐시를 사용하지 않고 매번 정보가 전송되는 것은 사용자로서도 불편하지만, 이용자가 많은 서비스일수록 서버에도 큰 부담이 된다. 전 세계의 수많은 사용자로부터 끊임없이 들어오는 요청을 처리하다 보면 아무리 고사양의 컴퓨터도 감당하기 어려운 부하가 걸린다. 이로 인한 응답 속도 저하나 서버 오류는 결국 사용자의 불편으로 이어진다.

이런 문제를 해결하기 위해 사용하는 것이 바로 `CDN(콘텐츠 전송 네트워크)`이다. CDN은 지리적으로 분산된 여러 개의 서버를 이용해 웹 컨텐츠를 사용자와 가까운 서버에서 전송함으로써 전송 속도를 높인다.

치킨 체인점이 전국의 주문을 본사에서 전부 처리하지 않고 각지의 체인점에서 받는 것처럼 일정 규모 이사의 사용자를 가진 서비스들은 CDN을 사용하여 사용자의 요청을 가까운 서버에서 분산 처리한다. 서버가 데이터를 전 세계 각지에 세워진 캐시 저장 및 전달용 컴퓨터(CDN 업체 소유)들에 보내면 사용자는 본 서버가 아닌 본인에게서 가장 가까운 캐시 서버로 요청을 보내고 데이터를 받아오는 것이다.

> CDN은 여러 지역에 설치된 캐시 서버들을 사용하여 본 서버로 들어오는 요청들을 분산 처리하는 서비스이다.
> 

CDN을 사용하면 본 서버는 캐시 서버에 데이터를 한 번씩만 전송하면 된다. CDN이 마치 세계적으로 유명한 체인점 같아서 본사의 부담을 최소화하고 사용자 역시 데이터를 보다 빠르고 안정적으로 받아올 수 있는 것이다. 대량의 데이터를 전송하는 서비스, 특히 유튜브나 넷플릭스와 같은 동영상 서비스에 CDN은 필수이다.

![CDN](https://github.com/byeongJoo05/Memo/assets/84984586/6dca81f3-10a3-4348-95d5-c7c3466f908c)